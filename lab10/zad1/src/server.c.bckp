#define _GNU_SOURCE

#include "server.h"
#include "stdlib.h"
#include "stdio.h"
#include "common.h"
#include "client.h"
#include <pthread.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netdb.h>
#include "string.h"
#include "unistd.h"
#include "time.h"
#include "sched.h"

int main(int argc, char *argv[]) {

    if (argc != DESIRED_NUM_PARAMS + 1) {

        printf("Usage: server <port_no> <path>\n");
        printf("\t<port_no> - port number to listen on\n");
        printf("\t<path> - path to Unix domain socket file\n");

        exit(1);
    }

    int sockets[MAX_CLIENTS];
    for(int i = 0; i < MAX_CLIENTS; ++i) {
        sockets[i] = -1;
    }

    char *char_portnum = argv[1];
//    char *unix_socket_path = argv[2];

    struct addrinfo hints, *res;
    int sockfd;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    getaddrinfo(NULL, char_portnum, &hints, &res);

    sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    sockets[0] = sockfd;
    bind(sockfd, res->ai_addr, res->ai_addrlen);
    listen(sockfd, MAX_WAITING_CONNECTIONS);


    fd_set orig;
    fd_set read_fd;

    FD_ZERO(&orig);
    FD_ZERO(&read_fd);

    FD_SET(sockfd, &orig);

    char buf[350];
    int maxfd = sockfd;
    struct sockaddr_storage remoteaddr;
    int newfd;
    int addrlen = sizeof remoteaddr;

    while(1 > 0) {

        printf("Sleep\n");

        read_fd = orig;
        if (select(maxfd+1, &read_fd, NULL, NULL, NULL) == -1) {
            error("select() error");
            exit(-1);
        }

        printf("Awake\n");

        for(int i = 0; i < MAX_CLIENTS; ++i) {

            if(sockets[i] != -1 && FD_ISSET(sockets[i], &read_fd)) {
                printf("%d is present\n", i);
                // accept new connection
                if(sockets[i] == sockfd) {
                    newfd = accept(sockfd, (struct sockaddr *)&remoteaddr, (socklen_t *)&addrlen);
                    if(newfd == -1) {
                        error("accept() error");
                    }
                    int j;
                    for(j = 0; j < MAX_CLIENTS; ++j) {
                        if(sockets[j] != -1) {
                            sockets[j] = newfd;
                            break;
                        }
                    }
                    if(j == MAX_CLIENTS) {
                        printf("Cannot accept more clients\n");
                    } else {
                        maxfd = newfd > maxfd ? newfd : maxfd;
                        FD_SET(newfd, &orig);
                        printf("Got new client\n");
                    }

                } else {
                    memset(buf, 0, 350);
                    recv(sockets[i], buf, 350, 0);
                    for(int j = 0; j < MAX_CLIENTS; ++j) {
                        if(j != i && sockets[j] != -1 && sockets[j] != sockfd) {
                            send(sockets[j], buf, strlen(buf)+1, 0);
                            printf("Sending from %d to %d \n", i, j);
                        }
                    }
                }

            }
        }

    }

    exit(0);
}